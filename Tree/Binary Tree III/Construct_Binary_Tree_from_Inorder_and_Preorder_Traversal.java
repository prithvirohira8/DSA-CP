// Problem Link: https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/

// Approach:
// This sum has a little tricky implementation and involves good understanding of 
// inorder and preorder array representations of binary trees.

// Preorder traversals follow the order: Root -> Left Child -> Right Child.
// Inorder traversals follow the order: Left Child -> Root -> Right Child.

// Hence it is safe to say the first index of the preorder array will be the root of the tree.
// Now if we observe the elements to the left of the root value in the inorder array shoud all be the children and grand children at the left.
// Similarly the elements to the right of the root value in the inorder array shoud all be the children and grand children at the right.

// We can recursively call this function again
// But how to get the root val for the children in recursion, inorder indices of 'l' &'h' to maintain the boundries while goind further?
// The very next index of the parent root in the preorder array would be thee root for the left children and ind of parent root + left children + 1 would be the ind of the root of the children at the right.
// Additionally the boundries can be maintained by identifying the no of nodes to the left and right of a particular node with the inorder array.
/// Note: Properly maintaining the boundries is 'crucial' here

/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
import java.util.*;

class Solution23 {

    static TreeNode solve(int preorder_root_ind, int inorder_l, int inorder_h, int[] preorder, int[] inorder,
            HashMap<Integer, Integer> hm) {
        int root_val = preorder[preorder_root_ind];
        TreeNode node = new TreeNode(root_val);

        int inorder_root_ind = hm.get(root_val);
        int nodes_to_left = inorder_root_ind - inorder_l;
        int nodes_to_right = inorder_h - inorder_root_ind;

        if (nodes_to_left <= 0)
            node.left = null;
        else
            node.left = solve(preorder_root_ind + 1, inorder_l, inorder_root_ind - 1, preorder, inorder, hm);

        if (nodes_to_right <= 0)
            node.right = null;
        else
            node.right = solve(preorder_root_ind + nodes_to_left + 1, inorder_root_ind + 1, inorder_h, preorder,
                    inorder, hm);

        return node;
    }

    public TreeNode buildTree(int[] preorder, int[] inorder) {
        HashMap<Integer, Integer> hm = new HashMap<>();
        for (int i = 0; i < inorder.length; i++) {
            hm.put(inorder[i], i);
        }
        return solve(0, 0, preorder.length - 1, preorder, inorder, hm);
    }
}

// Time Complexity: O(N)
// Recursively explore each node

// Space Complexity: O(N)
// Generated by Recursive Stack